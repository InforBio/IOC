---
title: "Building Logic:<br>Operators, Conditions, and Functions"
subtitle: "IOC-R Week 4"
format:
  revealjs: 
    toc: true
    toc-title: "Plan"
    toc-depth: 1
    slide-number: true
    preview-links: auto
    logo: ../../images/logoInforBio_fond_blanc_small.png
    css: ../custom.css
  # pdf:
  #   toc: true
echo: true
categories: 
  - week04
  - slides
image: images/preview_w4.png
---

# Recap Week 3

## Brief Recap Week 3 {.smaller}

::: {.columns}
::: {.column}
- Data frames: row-column structure

```{r}
df <- data.frame(x = 1:3, y = c("a", "b", "c"))
df
```

- Lists: store anything

```{r}
my_list <- list(x = 1:3, y = letters[5:1])
my_list
```
:::

::: {.column .fragment}

::: {.callout-note appearance="minimal"}
What are the outputs for following codes?
:::

```{r}
#| eval: false

df$x
df[[2]]
df[3, ]
df[, "y", drop = FALSE]
df[1, 2]
```

::: {.fragment}
<br>

```{r}
#| eval: false

my_list$x
my_list[1]
my_list["y"]
my_list[[2]][3]
```

:::

:::
:::


:::{.notes}
list is often used to store meta data

Motivation for Week 4
- Why learn operators, conditions, and functions?
- Real-world examples (e.g., filtering data, automating repetitive tasks, decision-making in analysis).
:::

# Operators

## Assignment and Arithmetic Operators {.smaller}

::: {.columns}
::: {.column}
- Assignment operators: `<-`, `->`, `=`

```{r}
x <- 1
x

2 -> x # not recommanded
x

y = "abc" # not recommanded
y
mean(x = 1:3) # assign value to functionâ€™s parameter
```
:::

::: {.column .fragment}
- Arithmetic operators: `+`, `-`, `*`, `/`, `^` (exponentiation), `%%` (remainder), *etc*.

```{r}
10^3
10 %% 3
```

::: {.fragment}

```{r}
x <- c(2, 8, 3)
x - 1
x - 1:3
```
:::

::: {.fragment}
```{r}
y <- c(6, 4, 1)
x + y
x * y
x / y
```
:::
:::
:::


## Comparison Operators {.smaller}

Element-wise comparison: `==`, `!=`, `>`, `<`, `>=`, `<=`,
return logical results.

::: {.columns}
::: {.column}

```{r}
10 == 3
10 != 3
10 > 3
10 >= 3
10 < 3
10 <= 3
```
:::
::: {.column .fragment}
```{r}
x <- c(2, 8, 3)
y <- c(6, 8, 1)
x == y
x != y
x > y
x <= y
```

:::
:::


## Logical Operators {.smaller}

Element-wise comparison: NOT (`!`), AND (`&`), OR (`|`), *etc.*,
returns logical values.

::: {.columns}
::: {.column}

```{r}
!TRUE
!FALSE
```

::: {.fragment}
For two conditions A and B:

| A     | B     | A & B | A \| B |
|-------|-------|-------|--------|
| TRUE  | TRUE  | **TRUE**  | TRUE   |
| TRUE  | FALSE | FALSE | TRUE   |
| FALSE | TRUE  | FALSE | TRUE   |
| FALSE | FALSE | FALSE | **FALSE**  |
:::

:::
::: {.column .fragment}

::: { .callout-note appearance="minimal"}
What are the expected results?

- `3 > 1 & 7 < 5`
- `3 > 1:3 | 7 < 5`
- `a` is a vector of numbers 1 to 5, `a[!a > 3]` returns?
:::

::: {.fragment}
```{r}
3 > 1 & 7 < 5
3 > 1:3 | 7 < 5
a <- 1:5
a[!a > 3]
```

:::
:::
:::

## The `%in%` Operator {.smaller}

We use `%in%` to check if left-side values are present in right-side,
it returns logical values.

::: {.columns}
::: {.column}
```{r}
## check membership
1 %in% 1:3
1:3 %in% 1
1:3 %in% 1:2
"a" %in% c("abc", "a")
```

:::
::: {.column}
::: {.fragment .callout-note appearance="minimal"}
Data frame `df` has two columns `x` and `y`,
what is the result of following code?

`! "col3" %in% colnames(df)`
:::

::: {.fragment}
```{r}
! "col3" %in% colnames(df)
```

:::
:::
:::


## Operator Precedence {.smaller}

::: {.columns}
::: {.column}
Simplified precedence order[^1] (highest to lowest):

1. Arithmetic (`^` > `*`, `/` > `+`, `-`)
2. Relational (`>`, `<`, `>=`, `<=`, `==`, `!=`)
3. Membership (`%in%`)
4. Logical (`!` > `&` > `|`)
:::
::: {.column .fragment}

Order can be change using `()`:

```{r}
1 + 2 * 3
(1 + 2) * 3
```

::: {.fragment}
```{r}
TRUE | TRUE & FALSE
```
:::
::: {.fragment}
```{r}
(TRUE | TRUE) & FALSE
```
:::

:::
:::

[^1]: For more detail, check the [operator documentation](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html).


## `any()`, `all()` and `which()` {.smaller}

Given a set of logical vectors: 
```{r}
-3:3
-3:3 > 0
```

- `any()`: is at least one of the values true?

```{r}
any(-3:3 > 0)
```

- `all()`: are all of the values true?

```{r}
all(-3:3 > 0)
```

- `which()`: return indices of `TRUE` values.

```{r}
which(-3:3 > 0)
```


# Conditions

## Conditional Statements {.smaller}

Conditional statements allow us to make decisions based on logical conditions,
guiding how the code behaves in different scenarios.

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  A{temperature > 37} --> B(TRUE)
  A --> C(FALSE)
  B --> D[Fever]
  C --> E[Normal]
```

. . . 

```{mermaid}
%%| echo: false
%%| fig-width: 10
flowchart LR
  A{log2FC > 0} --> B(TRUE)
  A --> C(FALSE)
  B --> D[Up-regulated]
  C --> E[Not up-regulated]
```


## `if` and `if else` {.smaller}

::: {.columns}
::: {.column}

Syntax:
```{r}
#| eval: false

## if statement
if (condition) {
  # code to run if `condition` is TRUE
}

## if else statement
if (condition) {
  # code to run if `condition` is TRUE
} else {
  # code to run if `condition` is FALSE
}
```

::: {.callout-important appearance="minimal"}
- You can use `if` without `else` but never in the opposite way.
- The condition is a **length-one logical vector** that is not NA.
:::
:::
::: {.column .fragment}

```{mermaid}
%%| echo: false
flowchart LR
  A{log2FC > 0} --> B(TRUE)
  A --> C(FALSE)
  B --> D[Up-regulated]
  C --> E[Not up-regulated]
```


```{r}
log2FC <- 2.5
if (log2FC > 0) {
  # code to run if condition is TRUE
  print("Up-regulated")
} else {
  # code to run if condition is FALSE
  print("Not up-regulated")
}
```

::: {.fragment .callout-note appearance="minimal"}
What will you get when `log2FC` is 0?
:::

::: {.fragment}
```{r}
#| echo: false

log2FC <- 0
if (log2FC > 0) {
  print("Up-regulated")
} else {
  print("Not up-regulated")
}
```
:::
:::
:::


## Handling Multiple Conditions (1) {.smaller}

- Decision depends on different cases of the same variable, we can use `if...else if...else`.

```{mermaid}
%%| echo: false
flowchart LR
  A{log2FC > 0} --> B(TRUE)
  A --> C(FALSE)
  B --> D[Up-regulated]
  C --> E{log2FC < 0}
  E --> F(TRUE) 
  F --> I[Down-regulated]
  E --> H(FALSE)
  H --> G[No change]
```

. . .

```{r}
log2FC <- -2.5
if (log2FC > 0) {
  print("Up-regulated")
} else if (log2FC < 0) {
  print("Down-regulated")
} else {
  print("No change")
}
```

## Handling Multiple Conditions (2) {.smaller}

- Nested `if else`: decisions depend on a combination of conditions, or if the second condition only applies after the first is true.

```{r}
pvalue <- 0.04
log2FC <- -1.5

if (pvalue < 0.05) {
  if (log2FC > 0) {
    print("Up-regulated")
  } else if (log2FC < 0) {
    print("Down-regulated")
  }
} else {
  print("Result not significant")
}
```

## Handling Multiple Conditions (3) {.smaller}

- Use logical operators (`&`, `|`, `!`) to combine multiple conditions.

```{r}
pvalue <- 0.06
log2FC <- 2.5

if (log2FC > 2 | log2FC < -2 & pvalue < 0.05) {
  print("candidate gene")
} else {
  print("condition NOT met")
}
```

. . . 

```{r}
if ((log2FC > 2 | log2FC < -2) & pvalue < 0.05) {
  print("candidate gene")
} else {
  print("condition NOT met")
}
```

::: {.callout-important appearance="minimal"}
- `&` has a **higher** priority than `|`.
- Use parentheses `()` to group conditions that need to be evaluated first.
:::

::: {.notes}
handle > 2 conditions.
precedence order
Improves code readability and ensures the correct order of evaluation.
:::


## The `ifelse()` Function  {.smaller}

Syntax:
```{r}
#| eval: false
ifelse(test, yes, no)
```

Example:

```{r}
log2FC <- -1
ifelse(test = log2FC > 0, yes = "Up-regulated", no = "Not up-regulated")
```

. . . 

```{r}
# nested condition
ifelse(
  test = log2FC > 0,
  yes = "Up-regulated",
  no = ifelse(log2FC < 0, yes = "Down-regulated", "No change")
)
```

. . .

The "test" can be a vector.

```{r}
vec_lfc <- c(-1, 0, 1)
ifelse(vec_lfc > 0, "Up-regulated", "Not up-regulated")
```


# Functions 

## What is a Function? {.smaller}

Functions = Reusable blocks of code.

::: {.columns .fragment}
::: {.column}

- Built-in functions

```{r}
mean(1:3)
```

::: {.notes}
Functions that are part of R's base installation, always available without needing to load any additional packages.
:::

- Custom functions

```{r}
add_one <- function(x) {x + 1}
add_one(x = 1:3)
```

:::
::: {.column}


- Functions from additional packages
```{r}
#| eval: false

library(readr)
read_csv("path/to/data.csv")
```

::: {.callout-tip appearance="minimal"}
We'll talk about packages next week!
:::

:::
:::

::: {.fragment .callout-tip appearance="minimal"}
Use `?` or `help()` to view the function's documentation, *e.g.*: `?mean`, `help(mean)`
:::

## Anatomy of a Function {.smaller}


::: {.columns}
::: {.column}

Syntax:
```{r}
function_name <- function(arguments) {
  # function code (body)
  return(result)
}
```

- The function name, be concise and preferably a verb.
- The reserved token `function()` and argument(s).
- The curly brackets `{}` frame the function code.
- The `return()` (usually) at the end will return a result.

:::

::: {.column .fragment}
::: {.callout-note appearance="minimal"}
What is the composition of the following function?
:::

```{.r code-line-numbers="|1,4|2|3"}
geo_mean <- function(x) {
  result <- exp(mean(log(x)))
  return(result)
}
```

:::
:::

## Functions with Conditions {.smaller}

Example: the geometric mean can only be calculated for positive numbers.
Use a condition to ensure this.

```{r}
geo_mean <- function(x) {
  # keep only positive values
  if (any(x <= 0)) {
    x <- x[x > 0]
  }
  # calculate geometric mean
  result <- exp(mean(log(x)))
  return(result)
}
```

:::{.notes}
geom mean is more suitable for data with a log-normal distribution or
when values have outliers or large differences in scale.
:::

## Local *vs.* Global Variables {.smaller}

- **Local** variable: defined **inside** the function.
- **Global** variable: defined **outside** and accessible anywhere.

```{r}
x <- 5
add_one <- function() {
  x <- 10
  return(x + 1)
}
add_one()  # Local, x is 10
x  # Global, x is 5
```

::: {.notes}
Scope in R, importance of proper scoping in functions.
:::

## Multiple Parameters {.smaller}

::: {.columns}
::: {.column}

```{r}
super_func <- function(arg1, arg2, arg3) {
  res <- arg1 + arg2 * arg3
  return(res)
}
```


:::{.fragment}
- Provide argument values in the expected order

```{r}
super_func(arg1 = 1, arg2 = 2, arg3 = 3)
super_func(1, 2, 3)
```

:::
:::
::: {.column .fragment}
- Provide argument values in a different order
```{r}
super_func(2, 1, 3)
super_func(arg2 = 2, arg1 = 1, arg3 = 3)
```
:::
:::

# Let's Practice !

## Today's Goals

- Understand and use operators to filter data with precision.
- Learn to interpret functions, write functions to automate tasks.