---
title: "Tidy Your Data:<br>Exploring {`tidyr`} and {`dplyr`}"
subtitle: "IOC-R Week 8"
date: "2025-03-10"
date-format: " "
format:
  revealjs: 
    toc: true
    toc-title: "Plan"
    toc-depth: 1
    slide-number: true
    preview-links: auto
    logo: ../../images/logoInforBio_fond_blanc_small.png
    css: ../custom.css
  # pdf:
  #   toc: true
echo: true
categories: 
  - week08
  - slides
image: images/preview_w8.png
---

# Recap `apply()` and `lapply()`

## `apply()` and `lapply()` {.smaller}

::: {.columns}
::: {.column}

```r
apply(X, MARGIN, FUN)
```

- `X`: a matrix or a data frame (coerced to a matrix)
- `MARGIN`: 1 for rows and 2 for columns
- `FUN`: the function to be applied

```{r}
mat <- matrix(1:9, nrow = 3)
apply(mat, 1, sum)
```

:::
::: {.column .fragment}

```r
lapply(X, FUN)
```

- `X`: a list or a vector
- `FUN`: the function to be applied

```{r}
my_list <- list(1, 2:3, 4:6)
lapply(my_list, sum)
sapply(my_list, sum) # simplified output
```

:::
:::

# Tidy Data with {`tidyr`} and {`dplyr`}

## Why Do We Need {`tidyverse`}? {.smaller}

Base R can be cumbersome â†’ {`tidyverse`} makes it simpler, with core packages such as:

  - [ggplot2](https://ggplot2.tidyverse.org/) (see session 5);
  - [**dplyr**](https://dplyr.tidyverse.org/): manipulate data;
  - [**tidyr**](https://tidyr.tidyverse.org/): restructure data;
  - [readr](https://readr.tidyverse.org/): import data into R;
  - [stringr](https://stringr.tidyverse.org/): manipulate strings (see session 9);
  - ...

```r
## install the core tidyverse packages
install.packages("tidyverse")

## load the core tidyverse packages
library(tidyverse)
```

```{r}
#| echo: false

library(tidyverse)
```

## The Pipe `|>` Operator {.smaller}

The pipe operator `|>` helps to execute codes in sequential,
it allows passing the input to the **first argument** of the function on the right-hand side.

::: {.columns}
::: {.column .fragment}

```{r}
# create a vector
x <- c(-3, -5, NA, 8)

# calculation with nested function
sqrt(mean(abs(x), na.rm = TRUE))

# alternative
# use variables to store intermediate result
abs_vals <- abs(x)
mean_val <- mean(abs_vals, na.rm = TRUE)
result <- sqrt(mean_val)
result
```

:::
::: {.column .fragment}

```{r}
# use pipe to make code easier to read
abs(x) |> mean(na.rm = TRUE) |> sqrt()

## or each function in one line
abs(x) |>
  mean(na.rm = TRUE) |>
  sqrt()
```

:::
:::


:::{.callout-tip appearance="minimal" .fragment}
- `|>` native pipe operator, built into base R (version 4.1+)
- `%>%` pipe from the {`magrittr`} package
:::

## What is a `tibble`? {.smaller}

A "modern" data frame, compatible with the data frame.

- Data imported by {`readr`} is in tibble format.

```{r}
readr::read_csv("../exos_data/read-counts.csv")
```

:::{.notes}
By default, tibble show a preview of the 10 first rows and
all columns that fit the screen with additional information.
:::


## What is a `tibble`? {.smaller}

A "modern" data frame, compatible with the data frame.


::: {.columns}
::: {.column}

<ul>
  <li> Create a tibble. </li>

```{r}
tibble(
  col1 = 1:2, col2 = c(TRUE, FALSE)
)
```

:::{.content-smaller}

  <ul>
    <li>`chr`: character</li>
    <li>`dbl`: double</li>
    <li>`int`: integer</li>
    <li>`fct`: factor</li>
    <li>`lgl`: logical</li>
    <li>`dttm`: date and time</li>
  </ul>
  
:::

</ul>

:::
::: {.column}

- Convert a data frame or a matrix into a tibble, with `as_tibble()` function. </li>

```{r}
iris <- as_tibble(iris)
iris |> head(3)
```

:::
:::


# Manipulate Data with {`dplyr`}

Cheat sheet: <https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf>

## {`dplyr`} - Selection {.smaller}

```r
?select
```

Select by column index.

::: {.columns}
::: {.column}
```{r}
colnames(iris)
# select one column
iris |> select(1) |> head(3)
# select mutiple columns
iris |> select(1, 3) |> head(3)
```

:::
::: {.column .fragment}
```{r}
# select a range of consecutive indices
iris |> select(1:3) |> head(3)
# use ! or - operator to negate a selection
iris |> select(!1:3) |> head(3)
iris |> select(-c(1:3)) |> head(3)
```

:::
:::


## {`dplyr`} - Selection {.smaller}

Select by column name.

::: {.columns}
::: {.column}

```{r}
colnames(iris)
# select one column
iris |> select(Species) |> head(3)
# select mutiple columns
iris |> select(Species, Sepal.Length) |> head(3) 
```

:::
::: {.column .fragment}
```{r}
# select a range of consecutive variables
iris |> select(Sepal.Length:Petal.Length) |> head(3)
# use ! or - operator to negate a selection
iris |> select(!(Sepal.Length:Petal.Length)) |> head(3)
iris |> select(-(Sepal.Length:Petal.Length)) |> head(3)
```

:::
:::


## {`dplyr`} - Selection {.smaller}

Select by using helper functions, by default case ignored when matching name.

::: {.columns}
::: {.column}

```{r}
colnames(iris)
iris |> select(starts_with("s")) |> head(3)
iris |> select(ends_with("S")) |> head(3)
```

:::
::: {.column}
```{r}
iris |> select(contains("Len")) |> head(3)
iris |> select(matches("len")) |> head(3)
# do not ignore case
select(iris, matches("len", ignore.case = FALSE))
```

:::
:::

## {`dplyr`} - Selection {.smaller}


# Restructure Data with {`tidyr`}

Cheat sheet: <https://github.com/rstudio/cheatsheets/blob/master/tidyr.pdf>

## The {`tidyr`} Package {.smaller}





# Let's Practice !

## Today's Goals

- 
- 
- 
- 
