---
title: "Tidy Your Data:<br>Exploring {`tidyr`} and {`dplyr`}"
subtitle: "IOC-R Week 8"
date: "2025-03-10"
date-format: " "
format:
  revealjs: 
    toc: true
    toc-title: "Plan"
    toc-depth: 1
    slide-number: true
    preview-links: auto
    logo: ../../images/logoInforBio_fond_blanc_small.png
    css: ../custom.css
  # pdf:
  #   toc: true
echo: true
categories: 
  - week08
  - slides
image: images/preview_w8.png
---

# Recap `apply()` and `lapply()`

## `apply()` and `lapply()` {.smaller}

::: {.columns}
::: {.column}

```r
apply(X, MARGIN, FUN)
```

- `X`: a matrix or a data frame (coerced to a matrix)
- `MARGIN`: 1 for rows and 2 for columns
- `FUN`: the function to be applied

```{r}
mat <- matrix(1:9, nrow = 3)
apply(mat, 1, sum)
```

:::
::: {.column .fragment}

```r
lapply(X, FUN)
```

- `X`: a list or a vector
- `FUN`: the function to be applied

```{r}
my_list <- list(1, 2:3, 4:6)
lapply(my_list, sum)
sapply(my_list, sum) # simplified output
```

:::
:::

# Tidy Data with {`tidyr`} and {`dplyr`}

## Why Do We Need {`tidyverse`}? {.smaller}

Base R can be cumbersome â†’ {`tidyverse`} makes it simpler, with core packages such as:

  - [ggplot2](https://ggplot2.tidyverse.org/) (see session 5);
  - [**dplyr**](https://dplyr.tidyverse.org/): manipulate data;
  - [**tidyr**](https://tidyr.tidyverse.org/): restructure data;
  - [readr](https://readr.tidyverse.org/): import data into R;
  - [stringr](https://stringr.tidyverse.org/): manipulate strings (see session 9);
  - ...

```r
## install the core tidyverse packages
install.packages("tidyverse")

## load the core tidyverse packages
library(tidyverse)
```

```{r}
#| echo: false

library(tidyverse)
```

## The Pipe `|>` Operator {.smaller}

The pipe operator `|>` helps to execute codes in sequential,
it allows passing the input to the **first argument** of the function on the right-hand side.

::: {.columns}
::: {.column .fragment}

```{r}
# create a vector
x <- c(-3, -5, NA, 8)

# calculation with nested function
sqrt(mean(abs(x), na.rm = TRUE))

# alternative
# use variables to store intermediate result
abs_vals <- abs(x)
mean_val <- mean(abs_vals, na.rm = TRUE)
result <- sqrt(mean_val)
result
```

:::
::: {.column .fragment}

```{r}
# use pipe to make code easier to read
abs(x) |>
  mean(na.rm = TRUE) |>
  sqrt()

## or each function in one line
abs(x) |>
  mean(na.rm = TRUE) |>
  sqrt()
```

:::
:::


:::{.callout-tip appearance="minimal" .fragment}
- `|>` native pipe operator, built into base R (version 4.1+)
- `%>%` pipe from the {`magrittr`} package
:::

## What is a `tibble`? {.smaller}

A "modern" data frame, compatible with the data frame.

- Data imported by {`readr`} is in tibble format.

```{r}
readr::read_csv("../exos_data/read-counts.csv")
```

:::{.notes}
By default, tibble show a preview of the 10 first rows and
all columns that fit the screen with additional information.
:::


## What is a `tibble`? {.smaller}

A "modern" data frame, compatible with the data frame.


::: {.columns}
::: {.column}

<ul>
  <li> Create a tibble. </li>

```{r}
tibble(
  col1 = 1:2, col2 = c(TRUE, FALSE)
)
```

:::{.content-smaller}

  <ul>
    <li>`chr`: character</li>
    <li>`dbl`: double</li>
    <li>`int`: integer</li>
    <li>`fct`: factor</li>
    <li>`lgl`: logical</li>
    <li>`dttm`: date and time</li>
  </ul>
  
:::

</ul>

:::
::: {.column}

- Convert a data frame or a matrix into a tibble, with `as_tibble()` function. </li>

```{r}
iris <- as_tibble(iris)
iris |> head(3)
```

:::
:::


# Manipulate Data with {`dplyr`}

Cheat sheet: <https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf>

## {`dplyr`} - `select()` Columns {.smaller}

```r
?select
```

Select by column index.

::: {.columns}
::: {.column}
```{r}
colnames(iris)
# select one column
iris |>
  select(1) |>
  head(3)
# select mutiple columns
iris |>
  select(1, 3) |>
  head(3)
```

:::
::: {.column .fragment}
```{r}
# select a range of consecutive indices
iris |>
  select(1:3) |>
  head(3)
# use ! or - operator to negate a selection
iris |>
  select(!1:3) |>
  head(3)
iris |>
  select(-c(1:3)) |>
  head(3)
```

:::
:::


## {`dplyr`} - `select()` Columns {.smaller}

Select by column name.

::: {.columns}
::: {.column}

```{r}
colnames(iris)
# select one column
iris |>
  select(Species) |>
  head(3)
# select mutiple columns
iris |>
  select(Species, Sepal.Length) |>
  head(3)
```

:::
::: {.column .fragment}
```{r}
# select a range of consecutive variables
iris |>
  select(Sepal.Length:Petal.Length) |>
  head(3)
# use ! or - operator to negate a selection
iris |>
  select(!(Sepal.Length:Petal.Length)) |>
  head(3)
iris |>
  select(-(Sepal.Length:Petal.Length)) |>
  head(3)
```

:::
:::


## {`dplyr`} - `select()` Columns {.smaller}

Select by using helper functions, by default case ignored when matching name.

::: {.columns}
::: {.column}

```{r}
colnames(iris)
iris |>
  select(starts_with("s")) |>
  head(3)
iris |>
  select(ends_with("S")) |>
  head(3)
```

:::
::: {.column}
```{r}
iris |>
  select(contains("Len")) |>
  head(3)
iris |>
  select(matches("len")) |>
  head(3)
# do not ignore case
select(iris, matches("len", ignore.case = FALSE))
```

:::
:::

## {`dplyr`} - `pull()` Column {.smaller}

Similar to `$` operator, `pull()` extracts one column and return results in a vector.

```{r}
# by default extract the last column
iris |>
  pull() |>
  head()

# extract by using explicite column name
iris |>
  pull(Species) |>
  head()
iris |>
  pull(Sepal.Width) |>
  head()
```

## {`dplyr`} - Adding/Modifying Columns {.smaller}

- Use `mutate()` to manipulate columns

```{r}
# create a new column
iris |> mutate(sepal_len_mm = Sepal.Length * 100) |> head(3)
# remove the column
iris |> mutate(index = NULL) |> head(3)

iris |>
  mutate(
    sepal_len_mm = Sepal.Length * 100,
    petal_len_mm = Petal.Length * 100
  ) |>
  head(3)
```

## {`dplyr`} - `if_else()` Function {.smaller}

Similar to the `ifelse()` function, but allow to mange missing values.

::: {.columns}
::: {.column}
```{r}
x <- c(-2:2, NA)
ifelse(x < 0, "negative", "positive")

if_else(x < 0, "negative", "positive", missing = "not available")
```

:::
::: {.column .fragment}

```{r}
iris |>
  mutate(sepal_len_cat = if_else(
    condition = Sepal.Length >= 7,
    true = "long",
    false = "normal",
    missing = "missing"
  )) |>
  select(Sepal.Length, Species, sepal_len_cat)
```

:::
:::

## {`dplyr`} - `rename()` Columns  {.smaller}

```{r}
iris |> rename(espece = Species, petal_width = Petal.Width)
```

## {`dplyr`} - `filter()` Rows {.smaller}

```{r}
iris |>
  filter(Species == "setosa") |>
  head(3)
iris |> filter(Sepal.Length >= 7.5)
```

## {`dplyr`} - `filter()` Rows {.smaller}

```{r}
# combine conditions
iris |> filter(Sepal.Length >= 7.5 & Petal.Length >= 6.5)

# chaining with other operation
iris |>
  filter(Sepal.Length >= 7.5 & Petal.Length >= 6.5) |>
  select(contains(c("sepal", "speci")))

```

:::{.callout-note appearance="minimal" .fragment}
Extract rows which correspond to setosa having sepal length smaller than 4.5 cm or
versicolor having petal width bigger than 1.5 cm.
:::

## {`dplyr`} - `slice()` Rows {.smaller}

- Use the function `slice()` to select rows.
```{r}
# create a column containing row index
iris$index <- seq_len(nrow(iris))

# extract rows 5 and 3
iris |> slice(5, 3)
```

- Use the `slice_head()` or `slice_tail()` to select the first or last rows.

```{r}
iris |> slice_head(n = 3)
iris |> slice_tail(n = 3)
```

:::{.callout-tip appearance="minimal"}
If data is a grouped data frame, `slice_head()` and `slice_tail()` will show the N first/last rows in each group.
:::


## {`dplyr`} - Grouping Data {.smaller}

- Use `group_by` to group data if we need operation based on defined group(s).

```{r}
iris |> slice_head(n = 2)
iris <- iris |> group_by(Species)
iris
```


## {`dplyr`} - Grouping Data {.smaller}

- Use `group_by` to group data if we need operation based on defined group(s).

```{r}
iris |> slice(2) # the 2nd row of each species
iris |> slice_head(n = 2) # the first 2 rows of each species
```

## {`dplyr`} - Grouping Data {.smaller}

- Use `ungroup()` to remove grouping

```{r}
iris <- iris |> ungroup()
iris |> slice_head(n = 5)
```

## {`dplyr`} - `arrange()` Rows {.smaller}

```{r}
# by default in ascending order
iris |> arrange(Sepal.Length) |> head(3)

# by descending order
iris |> arrange(desc(Sepal.Length)) |> head(3)

# based on multiple variables
iris |> arrange(desc(Sepal.Length), Sepal.Width) |> head(5)

```

## {`dplyr`} - `distinct()` Rows  {.smaller}

::: {.columns}
::: {.column}

```{r}
# use one variable to determine unique rows
iris |> distinct(Species)
# keep other columns 
iris |> distinct(Species, .keep_all = TRUE)
```

:::
::: {.column .fragment}
```{r}
# provide a data frame
iris |> select(Sepal.Length, Sepal.Width) |> distinct()
```

:::
:::


## {`dplyr`} - `count()` Rows  {.smaller}

- Check unique values of one or more variables.

```{r}
# count based on one variable
iris |> count(Species)

# count for the entire data frame
iris |> count()
```

## {`dplyr`} - `summarise()` Function  {.smaller}

```{r}
iris |>
  group_by(Species) |>
  summarise(
    mean_sepal_len = mean(Sepal.Length, na.rm = TRUE),
    sd_sepal_len = sd(Sepal.Length, na.rm = TRUE),
    n_sample = n() # n() gives the current group size
  )
```

## {`dplyr`} - `left_join()` Tables  {.smaller}

```{r}
data_geo <- tibble(
  Species = c("setosa", "virginica"),
  longitude = c(65.30, -20),
  latitude = c(45, -22.13)
)

left_join(x = iris, y = data_geo, by = "Species") |>
  group_by(Species) |>
  slice(1:2)
```


## {`dplyr`} - `right_join()` Tables  {.smaller}

```{r}
right_join(x = iris, y = data_geo, by = "Species") |>
  group_by(Species) |>
  slice(1:2)
```

:::{.callout-tip appearance="minimal"}
There are other types of join, such as `inner_join()`, `full_join()`, `anti_join()`,
please check the function's document.
:::

# Restructure Data with {`tidyr`}

Cheat sheet: <https://github.com/rstudio/cheatsheets/blob/master/tidyr.pdf>





## The {`tidyr`} Package {.smaller}





# Let's Practice !

## Today's Goals

- 
- 
- 
- 
